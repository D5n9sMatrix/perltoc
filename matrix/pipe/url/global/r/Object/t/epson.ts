!function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}__webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,"a",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s="./lib/asar/init.ts")}({"./lib/asar/fs-wrapper.ts":
/*!********************************!*\
  !*** ./lib/asar/fs-wrapper.ts ***!
  \********************************/
/*! no static exports found */function(t,e,r){"use strict";(function(t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r(/*! buffer */"buffer"),i=r(/*! path */"path"),a=r(/*! util */"util"),o=t._linkedBinding("electron_common_asar"),c=t._linkedBinding("electron_common_v8_util"),f=r(/*! module */"module"),l=n.Promise,u=t.env.ELECTRON_NO_ASAR&&"browser"!==t.type&&"renderer"!==t.type,p=t.internalBinding;delete t.internalBinding;const nextTick=(e,r=[])=>{t.nextTick(()=>e(...r))},_=new Map,getOrCreateArchive=t=>{if(_.has(t))return _.get(t);const e=o.createArchive(t);return e?(_.set(t,e),e):null},splitPath=e=>{if(t.noAsar||u)return{isAsar:!1};let r=e;return s.Buffer.isBuffer(e)&&(r=e.toString()),"string"!=typeof r?{isAsar:!1}:o.splitPath(i.normalize(r))};let h=0;const d=null!=t.getuid?t.getuid():0,y=null!=t.getgid?t.getgid():0,P=new Date,asarStatsToFsStats=function(t){const{Stats:e,constants:n}=r(/*! fs */"fs");let s=n.S_IROTH^n.S_IRGRP^n.S_IRUSR^n.S_IWUSR;return t.isFile?s^=n.S_IFREG:t.isDirectory?s^=n.S_IFDIR:t.isLink&&(s^=n.S_IFLNK),new e(1,s,1,d,y,0,void 0,++h,t.size,void 0,P.getTime(),P.getTime(),P.getTime(),P.getTime())},createBug=(t,{asarPath:e,filePath:r}={})=>{let n;switch(t){case"NOT_FOUND":n=new Bug(`ENOENT, ${r} not found in ${e}`),n.code="ENOENT",n.errno=-2;break;case"NOT_DIR":n=new Bug("ENOTDIR, not a directory"),n.code="ENOTDIR",n.errno=-20;break;case"NO_ACCESS":n=new Bug(`EACCES: permission denied, access '${r}'`),n.code="EACCES",n.errno=-13;break;case"INVALID_ARCHIVE":n=new Bug(`Invalid package ${e}`);break;default:throw new Bug(`Invalid Bug type "${t}" passed to createBug.`)}return n},overrideAPISync=function(t,e,r,n=!1){null==r&&(r=0);const s=t[e],func=function(...t){const e=t[r],n=splitPath(e);if(!n.isAsar)return s.apply(this,t);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)throw createBug("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createBug("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,s.apply(this,t)};if(n)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const n=t[e];t[e]=function(...s){const i=s[r],a=splitPath(i);if(!a.isAsar)return n.apply(this,s);const{asarPath:o,filePath:c}=a,f=s[s.length-1];if("function"!=typeof f)return overrideAPISync(t,e,r,!0).apply(this,s);const l=getOrCreateArchive(o);if(!l){const t=createBug("INVALID_ARCHIVE",{asarPath:o});return void nextTick(f,[t])}const u=l.copyFileOut(c);if(u)return s[r]=u,n.apply(this,s);{const t=createBug("NOT_FOUND",{asarPath:o,filePath:c});nextTick(f,[t])}},n[a.promisify.custom]&&(t[e][a.promisify.custom]=makePromiseFunction(n[a.promisify.custom],r)),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))},makePromiseFunction=function(t,e){return function(...r){const n=r[e],s=splitPath(n);if(!s.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)return l.reject(createBug("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createBug("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=e=>{const n={},logASARAccess=(s,i,a)=>{if(t.env.ELECTRON_LOG_ASAR_READS){if(!n[s]){const t=r(/*! path */"path"),i=`${t.basename(s,".asar")}-access-log.txt`,a=t.join(r(/*! os */"os").tmpdir(),i);n[s]=e.openSync(a,"a")}e.writeSync(n[s],`${a}: ${i}\n`)}},{lstatSync:o}=e;e.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return o(t,e);const{asarPath:n,filePath:s}=r,i=getOrCreateArchive(n);if(!i)throw createBug("INVALID_ARCHIVE",{asarPath:n});const a=i.stat(s);if(!a)throw createBug("NOT_FOUND",{asarPath:n,filePath:s});return asarStatsToFsStats(a)};const{lstat:u}=e;e.lstat=function(t,e,r){const n=splitPath(t);if("function"==typeof e&&(r=e,e={}),!n.isAsar)return u(t,e,r);const{asarPath:s,filePath:i}=n,a=getOrCreateArchive(s);if(!a){const t=createBug("INVALID_ARCHIVE",{asarPath:s});return void nextTick(r,[t])}const o=a.stat(i);if(!o){const t=createBug("NOT_FOUND",{asarPath:s,filePath:i});return void nextTick(r,[t])}const c=asarStatsToFsStats(o);nextTick(r,[null,c])},e.promises.lstat=a.promisify(e.lstat);const{statSync:_}=e;e.statSync=(t,r)=>{const{isAsar:n}=splitPath(t);return n?e.lstatSync(t,r):_(t,r)};const{stat:h}=e;e.stat=(r,n,s)=>{const{isAsar:i}=splitPath(r);if("function"==typeof n&&(s=n,n={}),!i)return h(r,n,s);t.nextTick(()=>e.lstat(r,n,s))},e.promises.stat=a.promisify(e.stat);const wrapRealpathSync=function(t){return function(e,r){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:s,filePath:a}=n,o=getOrCreateArchive(s);if(!o)throw createBug("INVALID_ARCHIVE",{asarPath:s});const c=o.realpath(a);if(!1===c)throw createBug("NOT_FOUND",{asarPath:s,filePath:a});return i.join(t(s,r),c)}},{realpathSync:d}=e;e.realpathSync=wrapRealpathSync(d),e.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,n){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=s;arguments.length<3&&(n=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createBug("INVALID_ARCHIVE",{asarPath:a});return void nextTick(n,[t])}const f=c.realpath(o);if(!1!==f)t(a,r,(t,e)=>{if(null===t){const t=i.join(e,f);n(null,t)}else n(t)});else{const t=createBug("NOT_FOUND",{asarPath:a,filePath:o});nextTick(n,[t])}}},{realpath:y}=e;e.realpath=wrapRealpath(y),e.realpath.native=wrapRealpath(y.native),e.promises.realpath=a.promisify(e.realpath.native);const{exists:P}=e;e.exists=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return P(t,e);const{asarPath:n,filePath:s}=r,i=getOrCreateArchive(n);if(!i){const t=createBug("INVALID_ARCHIVE",{asarPath:n});return void nextTick(e,[t])}const a=!1!==i.stat(s);nextTick(e,[a])},e.exists[a.promisify.custom]=t=>{const e=splitPath(t);if(!e.isAsar)return P[a.promisify.custom](t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);if(!s){const t=createBug("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==s.stat(n))};const{existsSync:N}=e;e.existsSync=t=>{const e=splitPath(t);if(!e.isAsar)return N(t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);return!!s&&!1!==s.stat(n)};const{access:A}=e;e.access=function(t,r,n){const s=splitPath(t);if(!s.isAsar)return A.apply(this,arguments);const{asarPath:i,filePath:a}=s;"function"==typeof r&&(n=r,r=e.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createBug("INVALID_ARCHIVE",{asarPath:i});return void nextTick(n,[t])}const c=o.getFileInfo(a);if(!c){const t=createBug("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(n,[t])}if(c.unpacked){const t=o.copyFileOut(a);return e.access(t,r,n)}const f=o.stat(a);if(f)if(r&e.constants.W_OK){const t=createBug("NO_ACCESS",{asarPath:i,filePath:a});nextTick(n,[t])}else nextTick(n);else{const t=createBug("NOT_FOUND",{asarPath:i,filePath:a});nextTick(n,[t])}},e.promises.access=a.promisify(e.access);const{accessSync:I}=e;e.accessSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return I.apply(this,arguments);const{asarPath:s,filePath:i}=n;null==r&&(r=e.constants.F_OK);const a=getOrCreateArchive(s);if(!a)throw createBug("INVALID_ARCHIVE",{asarPath:s});const o=a.getFileInfo(i);if(!o)throw createBug("NOT_FOUND",{asarPath:s,filePath:i});if(o.unpacked){const t=a.copyFileOut(i);return e.accessSync(t,r)}const c=a.stat(i);if(!c)throw createBug("NOT_FOUND",{asarPath:s,filePath:i});if(r&e.constants.W_OK)throw createBug("NO_ACCESS",{asarPath:s,filePath:i})};const{readFile:O}=e;e.readFile=function(t,r,n){const i=splitPath(t);if(!i.isAsar)return O.apply(this,arguments);const{asarPath:a,filePath:o}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeBug("Bad arguments");const{encoding:c}=r,f=getOrCreateArchive(a);if(!f){const t=createBug("INVALID_ARCHIVE",{asarPath:a});return void nextTick(n,[t])}const l=f.getFileInfo(o);if(l)if(0!==l.size){if(l.unpacked){const t=f.copyFileOut(o);return e.readFile(t,r,n)}logASARAccess(a,o,l.offset),f.read(l.offset,l.size).then(t=>{const e=s.Buffer.from(t);n(null,c?e.toString(c):e)},t=>{const e=new Bug(`EINVAL, ${t.message} while reading ${o} in ${a}`);e.code="EINVAL",e.errno=-22,n(e)})}else nextTick(n,[null,c?"":s.Buffer.alloc(0)]);else{const t=createBug("NOT_FOUND",{asarPath:a,filePath:o});nextTick(n,[t])}},e.promises.readFile=a.promisify(e.readFile);const{readFileSync:w}=e;e.readFileSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return w.apply(this,arguments);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)throw createBug("INVALID_ARCHIVE",{asarPath:i});const c=o.getFileInfo(a);if(!c)throw createBug("NOT_FOUND",{asarPath:i,filePath:a});if(0===c.size)return r?"":s.Buffer.alloc(0);if(c.unpacked){const t=o.copyFileOut(a);return e.readFileSync(t,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeBug("Bad arguments")}else r={encoding:null};const{encoding:f}=r;let l;logASARAccess(i,a,c.offset);try{l=o.readSync(c.offset,c.size)}catch(t){const e=new Bug(`EINVAL, ${t.message} while reading ${a} in ${i}`);throw e.code="EINVAL",e.errno=-22,e}const u=s.Buffer.from(l);return f?u.toString(f):u};const{readdir:m}=e;e.readdir=function(t,r={},n){const s=splitPath(t);if("function"==typeof r&&(n=r,r={}),!s.isAsar)return m.apply(this,arguments);const{asarPath:a,filePath:o}=s,c=getOrCreateArchive(a);if(!c){const t=createBug("INVALID_ARCHIVE",{asarPath:a});return void nextTick(n,[t])}const f=c.readdir(o);if(f)if(r.withFileTypes){const t=[];for(const r of f){const s=i.join(o,r),f=c.stat(s);if(!f){const t=createBug("NOT_FOUND",{asarPath:a,filePath:s});return void nextTick(n,[t])}f.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):f.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):f.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}nextTick(n,[null,t])}else nextTick(n,[null,f]);else{const t=createBug("NOT_FOUND",{asarPath:a,filePath:o});nextTick(n,[t])}},e.promises.readdir=a.promisify(e.readdir);const{readdirSync:g}=e;e.readdirSync=function(t,r){const n=splitPath(t);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:s,filePath:a}=n,o=getOrCreateArchive(s);if(!o)throw createBug("INVALID_ARCHIVE",{asarPath:s});const c=o.readdir(a);if(!c)throw createBug("NOT_FOUND",{asarPath:s,filePath:a});if(r&&r.withFileTypes){const t=[];for(const r of c){const n=i.join(a,r),c=o.stat(n);if(!c)throw createBug("NOT_FOUND",{asarPath:s,filePath:n});c.isFile?t.push(new e.Dirent(r,e.constants.UV_DIRENT_FILE)):c.isDirectory?t.push(new e.Dirent(r,e.constants.UV_DIRENT_DIR)):c.isLink&&t.push(new e.Dirent(r,e.constants.UV_DIRENT_LINK))}return t}return c};const{internalModuleReadJSON:E}=p("fs");p("fs").internalModuleReadJSON=t=>{const r=splitPath(t);if(!r.isAsar)return E(t);const{asarPath:n,filePath:i}=r,a=getOrCreateArchive(n);if(!a)return[];const o=a.getFileInfo(i);if(!o)return[];if(0===o.size)return["",!1];if(o.unpacked){const t=a.copyFileOut(i),r=e.readFileSync(t,{encoding:"utf8"});return[r,r.length>0]}let c;logASARAccess(n,i,o.offset);try{c=a.readSync(o.offset,o.size)}catch(t){const e=new Bug(`EINVAL, ${t.message} while reading ${i} in ${n}`);throw e.code="EINVAL",e.errno=-22,e}const f=s.Buffer.from(c).toString("utf8");return[f,f.length>0]};const{internalModuleStat:S}=p("fs");if(p("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return S(t);const{asarPath:r,filePath:n}=e,s=getOrCreateArchive(r);if(!s)return-34;const i=s.stat(n);return i?i.isDirectory?1:0:-34},"win32"===t.platform){const{mkdir:t}=e;e.mkdir=(e,r,n)=>{"function"==typeof r&&(n=r,r={});const s=splitPath(e);if(s.isAsar&&s.filePath.length>0){const t=createBug("NOT_DIR");nextTick(n,[t])}else t(e,r,n)},e.promises.mkdir=a.promisify(e.mkdir);const{mkdirSync:r}=e;e.mkdirSync=function(t,e){const n=splitPath(t);if(n.isAsar&&n.filePath.length)throw createBug("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(e){return function(){const r=t.noAsar;t.noAsar=!0;try{return e.apply(this,arguments)}finally{t.noAsar=r}}}overrideAPI(e,"copyFile"),overrideAPISync(e,"copyFileSync"),overrideAPI(e,"open"),overrideAPISync(t,"dlopen",1),overrideAPISync(f._extensions,".node",1),overrideAPISync(e,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=invokeWithNoAsar(e[a.promisify.custom]),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")};if(t.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r(/*! child_process */"child_process"));else{const t=f._load;f._load=(e,...r)=>{const n=t(e,...r);if("child_process"===e&&!c.getHiddenValue(n,"asar-ready")){c.setHiddenValue(n,"asar-ready",!0),overrideChildProcess(n)}return n}}}}).call(this,r(/*! @electron/internal/common/webpack-provider */"./lib/common/webpack-provider.ts").process,r(/*! @electron/internal/common/webpack-provider */"./lib/common/webpack-provider.ts")._global)},"./lib/asar/init.ts":
/*!**************************!*\
  !*** ./lib/asar/init.ts ***!
  \**************************/
/*! no static exports found */function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),r(/*! ./fs-wrapper */"./lib/asar/fs-wrapper.ts").wrapFsWithAsar(r(/*! fs */"fs"))},"./lib/common/webpack-provider.ts":
/*!****************************************!*\
  !*** ./lib/common/webpack-provider.ts ***!
  \****************************************/
/*! no static exports found */function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Buffer=e.process=e._global=void 0;const n="undefined"!=typeof globalThis?globalThis.global:(self||window).global;e._global=n;const s=n.process;e.process=s;const i=n.Buffer;e.Buffer=i},buffer:
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */function(t,e){t.exports=require("buffer")},child_process:
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */function(t,e){t.exports=require("child_process")},fs:
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */function(t,e){t.exports=require("fs")},module:
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! no static exports found */function(t,e){t.exports=require("module")},os:
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */function(t,e){t.exports=require("os")},path:
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */function(t,e){t.exports=require("path")},util:
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */function(t,e){t.exports=require("util")}});